from pylab import *
from numpy import *
import scipy.optimize
from openravepy import *
import Trajectory

TINY = 1e-5

# Simple class to handle a chunk of the velocity profile
class Chunk(object):
    def __init__(self,t0,v0,t1,v1):
        assert(t1-t0>0)
        self.t0 = t0
        self.v0 = v0
        self.t1 = t1
        self.v1 = v1
        self.acc = (v1-v0)/(t1-t0)
        self.T = t1-t0
        self.ndof = len(v0)

    def Shift(self,tshift):
        self.t0 += tshift
        self.t1 += tshift
        
    def SetStart(self,tstart):
        self.t0 = tstart
        self.t1 = tstart + self.T
    
    def SetDuration(self,newT):
        self.T = newT
        self.t1 = self.t0 + newT

    def Plot(self,color):
        for i in range(self.ndof):
            plot([self.t0,self.t1],[self.v0[i],self.v1[i]],color[i],linewidth=2)


# Compute the optimal velocity profile between q0 and q1 given the max velocities and accelerations
def ComputeChunks(q0,q1,vmaxl,amaxl,tstart):
    reslist = []
    ndof = len(q0)
    vmax = 1e10
    amax = 1e10
    for i in range(ndof):
        if abs(q1[i]-q0[i])>TINY:
            vmax = min(vmaxl[i]/abs(q1[i]-q0[i]),vmax)
            amax = min(amaxl[i]/abs(q1[i]-q0[i]),amax)
    tp = sqrt(1/amax)
    a = (q1-q0)*amax
    if tp*amax <= vmax :
        v = (q1-q0)*tp*amax
        reslist.append(Chunk(tstart,zeros(ndof),tstart+tp,v))
        reslist.append(Chunk(tstart+tp,v,tstart+2*tp,zeros(ndof)))
    else:
        v = (q1-q0)*vmax
        t = vmax/amax
        t2 = 1/vmax - vmax/amax
        reslist.append(Chunk(tstart,zeros(ndof),tstart+t,v))
        reslist.append(Chunk(tstart+t,v,tstart+t+t2,v))
        reslist.append(Chunk(tstart+t+t2,v,tstart+2*t+t2,zeros(ndof)))
    return reslist


# Merge the decelerating chunka with the following sequence chunksb
# of 2 (accel,decel) or 3 chunks (accel,max velocity,decel)
def MergeChunks(chunka,chunkbs):
    for i in range(chunka.ndof):
        assert(abs(chunka.v1[i])<TINY)
        assert(abs(chunkbs[0].v0[i])<TINY)
    reslist = []
    if(len(chunkbs)==2 or chunka.T<chunkbs[0].T or chunkbs[1].T<(chunka.T-chunkbs[0].T)/2.):
        chunkb = chunkbs[0]
        chunkbb = chunkbs[1]
        if(chunka.T>=chunkb.T):
            tadd = chunka.T - chunkb.T
            tnew = chunka.t0 + tadd
            vnew = chunka.v0+chunka.acc*tadd
            tnew2 = chunka.t1
        else:
            tadd = chunka.T
            tnew = chunka.t1
            vnew = tadd*chunkb.acc
            tnew2 = chunka.t0+chunkb.T
        if(tnew - chunka.t0 >= TINY):
            reslist.append(Chunk(chunka.t0,chunka.v0,tnew,vnew))
        if(tnew2-tnew >= TINY):
            reslist.append(Chunk(tnew,vnew,tnew2,chunkb.v1))
        chunkbb.SetStart(tnew2)
        reslist.append(chunkbb)
        if(len(chunkbs)==3):
            chunkbbb = chunkbs[2]
            chunkbbb.SetStart(chunkbb.t1)
            reslist.append(chunkbbb)
    else: 
        # here chunksb has size 3 and chunka.T >= chunkbs[0].T and chunkbs[1].T>=(chunka.T-chunkbs[0].T)/2.)
        # in this case, we connect the two max velocities by a straight line
        # and compensate by reducing the time duration of chunksb[1] by (chunka.T-chunkbs[0].T)/2.
        chunkb = chunkbs[0]
        chunkbb = chunkbs[1]
        chunkbbb = chunkbs[2]
        tnew = chunka.t0+chunka.T
        reslist.append(Chunk(chunka.t0,chunka.v0,tnew,chunkb.v1))
        chunkbb.SetStart(tnew)
        chunkbb.SetDuration(chunkbb.T-(chunka.T-chunkb.T)/2.)
        reslist.append(chunkbb)
        chunkbbb.SetStart(chunkbb.t1)
        reslist.append(chunkbbb)    
    return reslist


# Make a TOPP chunk from a velocity chunk and initial dof values
def MakeTOPPChunk(vchunk,q0):
    polylist = []
    for i in range(vchunk.ndof):
        polylist.append(Trajectory.Polynomial([q0[i],vchunk.v0[i],0.5*(vchunk.v1[i]-vchunk.v0[i])/vchunk.T]))
    return Trajectory.Chunk(vchunk.T,polylist)


# Compute the full trajectory that would be generated by denso given a sequence of waypoints
def Interpolate(qlist,vmax,amax,vcoeflist=[],acoeflist=[],tstart=0):
    npoints = len(qlist)
    assert(npoints>=3)
    if(len(vcoeflist) == 0):
        vcoeflist = ones(npoints-1)
    if(len(acoeflist) == 0):
        acoeflist = ones(npoints-1)
    assert(len(vcoeflist)==npoints-1 and len(acoeflist)==npoints-1)
    q0 = qlist[0]
    qcur = qlist[1]
    reslist =  ComputeChunks(q0,qcur,min(1,max(TINY,vcoeflist[0]))*vmax,min(1,max(TINY,acoeflist[0]))*amax,tstart)
    for i in range(2,npoints):            
        qnext = qlist[i]
        chunkslistb =  ComputeChunks(qcur,qnext,min(1,max(TINY,vcoeflist[i-1]))*vmax,min(1,max(TINY,acoeflist[i-1]))*amax,0)
        chunka = reslist.pop(-1)
        listmerge = MergeChunks(chunka,chunkslistb)
        reslist.extend(listmerge)
        qcur = qnext
    # Make a TOPP Trajectory
    topplist = []
    qcur = qlist[0]
    for i in range(len(reslist)):
        toppchunk = MakeTOPPChunk(reslist[i],qcur)
        qcur = toppchunk.Eval(toppchunk.duration)
        topplist.append(toppchunk)
    return Trajectory.PiecewisePolynomialTrajectory(topplist)
          

# Make a vector from a sequence of waypoints and coeflist
def VectorFromList(qlist,vcoeflist=[],acoeflist=[]):
    ndof = len(qlist[0])
    nwaypoints = len(qlist)-2
    assert(nwaypoints>0)
    n = ndof*nwaypoints
    x = zeros(n+2*len(vcoeflist))
    for i in range(nwaypoints):
        x[i*ndof:(i+1)*ndof] = qlist[i+1]
    if(len(vcoeflist)>0):
        assert(len(vcoeflist)==nwaypoints+1 and len(acoeflist)==nwaypoints+1)
        x[n:n+nwaypoints+1] = vcoeflist
        x[n+nwaypoints+1:n+2*nwaypoints+2] = acoeflist
    return x      
    
# Make a list of waypoints from the vector
def ListFromVector(x,ndof,nwaypoints):
    # Extract the waypoints
    qlist = []
    for i in range(nwaypoints):
        qlist.append(x[i*ndof:(i+1)*ndof])
    # Extract the vcoefs and acoefs, if any
    if(len(x) > ndof*nwaypoints):
        n = ndof*nwaypoints
        vcoeflist = x[n:n+nwaypoints+1]
        acoeflist = x[n+nwaypoints+1:n+2*nwaypoints+2]
    else:
        vcoeflist = []
        acoeflist = []
    return qlist,vcoeflist,acoeflist
                                                                                                                                         
# Construct a trajectory from a vector
def MakeTraj(x,qstart,qend,ndof,nwaypoints,vmax,amax):
    qlist,vcoeflist,acoeflist = ListFromVector(x,ndof,nwaypoints)
    qlist.insert(0,qstart)
    qlist.append(qend)
    return Interpolate(qlist,vmax,amax,vcoeflist,acoeflist,0)
        

# Objective function for waypoint optimization
def ObjFunc(x,qstart,qend,ndof,nwaypoints,nsamples,weights,vmax,amax,trajref,robot):
    traj = MakeTraj(x,qstart,qend,ndof,nwaypoints,vmax,amax)
    dpos, dvel, dacc = Trajectory.Diff3(traj,trajref,nsamples,robot)
    cpos, cvel, cacc, cdur = weights
    cost = cpos*dpos*dpos + cvel*dvel*dvel + cacc*dacc*dacc + cdur*(traj.duration-trajref.duration)
    print cost, cpos*dpos*dpos, cvel*dvel*dvel, cacc*dacc*dacc, cdur*(traj.duration-trajref.duration)
    return cost
    

# Find the optimal sequence of waypoints to track a reference trajectory
def FindOptTraj(trajref,nwaypoints,nsamples,weights,vmax,amax,gainoptim = False,robot=None,maxiter=None,maxfun=None):
    ndof = trajref.dimension
    qstart = trajref.Eval(0)
    qend = trajref.Eval(trajref.duration)
    x0 = zeros(ndof*nwaypoints)
    waypoints = linspace(0,trajref.duration,nwaypoints+2)
    for i in range(1,nwaypoints+1):
        x0[(i-1)*ndof:i*ndof] = trajref.Eval(waypoints[i])
    # In case ones want also to optimize the velocity and acceleration gains
    if(gainoptim):
        vcoeflist = ones(nwaypoints+1)
        acoeflist = ones(nwaypoints+1)
        for i in range(nwaypoints+1):
            subsamples = int(nsamples*(waypoints[i+1]-waypoints[i])/trajref.duration)
            v,a = GuessGain(trajref,waypoints[i],waypoints[i+1],subsamples+1,vmax,amax)
            print v,a
            vcoeflist[i] = v
            acoeflist[i] = a
        n = ndof*nwaypoints
        x0bis = zeros(n+2*nwaypoints+2)
        x0bis[0:n] = x0
        x0bis[n:n+nwaypoints+1] = vcoeflist
        x0bis[n+nwaypoints+1:n+2*nwaypoints+2] = acoeflist
        x0 = x0bis
    xopt = scipy.optimize.fmin_powell(ObjFunc,x0,args=(qstart,qend,ndof,nwaypoints,nsamples,weights,vmax,amax,trajref,robot),maxiter=maxiter,maxfun=maxfun)
    print "Final: ",ObjFunc(xopt,qstart,qend,ndof,nwaypoints,nsamples,weights,vmax,amax,trajref,robot)
    return xopt


# Guess the velocity and acceleration gain at a time instant
def GuessGain(trajref,t0,t1,subsamples,vmax,amax):
    samplepoints = linspace(t0,t1,subsamples)
    ndof = trajref.dimension
    vm = zeros(ndof)
    am = zeros(ndof)
    for t in samplepoints:
        v = trajref.Evald(t)
        a = trajref.Evaldd(t)
        for i in range(ndof):
            vm[i] += abs(v[i])
            am[i] += abs(a[i])
    vcoef = zeros(ndof)
    acoef = zeros(ndof)
    for i in range(ndof):
        vcoef[i]=vm[i]/subsamples/vmax[i]
        acoef[i]=am[i]/subsamples/amax[i]
    return max(vcoef),max(vcoef)


# Array to string
def arraytostring(a):
    if len(a) < 1:
        return ""
    restring = str(a[0])
    for i in range(1,len(a)):
        restring += "," + str(a[i])
    return restring


# Create a denso pcs program from a sequence of waypoints
def CreateProgram(qlist,filename,vcoeflist=[],acoeflist=[], nextracols=0):
    ndof = len(qlist[0])    
    nwaypoints = len(qlist)-2
    gainoptim = len(vcoeflist)>0
    fullvalues = zeros(ndof+nextracols)
    restring = "Sub Main \n TakeArm Keep = 1\n"

    # First waypoint    
    fullvalues[0:ndof] = qlist[0]*180/pi  
    restring += "  Move P, @E J(" + arraytostring(fullvalues) + ")\n" 
    restring += "  Delay 1000\n"

    # Intermediate waypoints
    for i in range(nwaypoints):
        fullvalues[0:ndof] = qlist[i+1]*180/pi  
        restring += "  Move P, @P J(" + arraytostring(fullvalues) + ")"
        if gainoptim:
            v = min(1,max(TINY,vcoeflist[i]))*100
            a = min(1,max(TINY,acoeflist[i]))*100
            restring += ", Speed=" + str(v) + ", Accel=" + str(a)
        restring += "\n" 

    # Final waypoint
    fullvalues[0:ndof] = qlist[-1]*180/pi
    restring += "  Move P, @E J(" + arraytostring(fullvalues) + ")"
    if gainoptim:
        v = min(1,max(TINY,vcoeflist[-1]))*100
        a = min(1,max(TINY,acoeflist[-1]))*100
        restring += ", Speed=" + str(v) + ", Accel=" + str(a)
    restring += "\n" 

    restring += "End Sub\n"    
    handle = open(filename,"w")
    handle.write(restring)
    handle.close()


# Create a denso pcs program from a sequence of waypoints
def CreateProgramBCAP(qlist,filename,vcoeflist=[],acoeflist=[], nextracols=0):
    ndof = len(qlist[0])    
    nwaypoints = len(qlist)-2
    gainoptim = len(vcoeflist)>0
    fullvalues = zeros(ndof+nextracols)
    restring = ""

    # First waypoint    
    fullvalues[0:ndof] = qlist[0]*180/pi  
    restring += "J(" + arraytostring(fullvalues) + ")\n" 
    restring += "Speed=100, Accel=100\n"

    # Intermediate waypoints
    for i in range(nwaypoints):
        fullvalues[0:ndof] = qlist[i+1]*180/pi  
        restring += "@P J(" + arraytostring(fullvalues) + ")\n"
        if gainoptim:
            v = min(1,max(TINY,vcoeflist[i]))*100
            a = min(1,max(TINY,acoeflist[i]))*100
            restring += "Speed=" + str(v) + ", Accel=" + str(a)
        else:
            restring += "Speed=100, Accel=100"            
        restring += "\n" 

    # Final waypoint
    fullvalues[0:ndof] = qlist[-1]*180/pi
    restring += "@P J(" + arraytostring(fullvalues) + ")\n"
    if gainoptim:
        v = min(1,max(TINY,vcoeflist[-1]))*100
        a = min(1,max(TINY,acoeflist[-1]))*100
        restring += "Speed=" + str(v) + ", Accel=" + str(a)
    else:
        restring += "Speed=100, Accel=100"            
    restring += "\n" 

    handle = open(filename,"w")
    handle.write(restring)
    handle.close()



# Plot the kinematics of the trajectories
def PlotKinematics(traj0, traj1, dt=0.01, vmax=[], amax=[], figstart=0, colorcycle = ['r', 'g', 'b', 'm', 'c', 'y', 'k'],tstart=0,robot=None,rescale=False):
    from pylab import figure, clf, hold, gca, title, xlabel, ylabel, plot, axis
    colorcycle = colorcycle[0:traj0.dimension]
    if traj0 is None:
        Tmax = traj1.duration
    elif traj1 is None:
        Tmax = traj0.duration
    else:
        Tmax = max(traj0.duration, traj1.duration)

    c=1
    if rescale:
        c = traj0.duration/traj1.duration

    # Joint angles
    figure(figstart)
    hold('on')
    ax = gca()
    ax.set_color_cycle(colorcycle)
    if(traj0!=None):
        traj0.Plot(dt, f='--',tstart=tstart)
    ax.set_color_cycle(colorcycle)
    if(traj1!=None):
        traj1.Plot(dt,tstart=tstart,c=c)
    title('Joint values', fontsize=20)
    xlabel('Time (s)', fontsize=18)
    ylabel('Joint values (rad)', fontsize=18)

    # Velocity
    figure(figstart + 1)
    hold('on')
    ax = gca()
    ax.set_color_cycle(colorcycle)
    if(traj0!=None):
        traj0.Plotd(dt, f='--',tstart=tstart)
    ax.set_color_cycle(colorcycle)
    if(traj1!=None):
        traj1.Plotd(dt,tstart=tstart,c=c)
    for v in vmax:
        plot([0, Tmax], [v, v], '-.')
    for v in vmax:
        plot([0, Tmax], [-v, -v], '-.')
    if len(vmax) > 0:
        Vmax = 1.2 * max(vmax)
        if Vmax < 0.1:
            Vmax = 10
        axis([0, Tmax, -Vmax, Vmax])
    title('Joint velocities', fontsize=20)
    xlabel('Time (s)', fontsize=18)
    ylabel('Joint velocities (rad/s)', fontsize=18)

    # Acceleration
    figure(figstart + 2)
    ax = gca()
    ax.set_color_cycle(colorcycle)
    hold('on')
    if(traj0!=None):
        traj0.Plotdd(dt, f='--',tstart=tstart)
    ax.set_color_cycle(colorcycle)
    if(traj1!=None):
        traj1.Plotdd(dt,tstart=tstart,c=c)
    for a in amax:
        plot([0, Tmax], [a, a], '-.')
    for a in amax:
        plot([0, Tmax], [-a, -a], '-.')
    if len(amax) > 0:
        Amax = 1.2 * max(amax)
        axis([0, Tmax, -Amax, Amax])
    title('Joint accelerations', fontsize=20)
    xlabel('Time (s)', fontsize=18)
    ylabel('Joint accelerations (rad/s^2)', fontsize=18)

    # End effector
    figure(figstart + 3)
    ax = gca()
    ax.set_color_cycle(colorcycle)
    hold('on')
    if(traj0!=None):
        traj0.Plotendeff(dt, f='--',tstart=tstart,robot=robot)
    ax.set_color_cycle(colorcycle)
    if(traj1!=None):
        traj1.Plotendeff(dt,tstart=tstart,c=c,robot=robot)
    title('End effector velocities and accelerations', fontsize=20)
    xlabel('Time (s)', fontsize=18)



# Detect the onset of a signal
def detect_onset(a,start = 0,threshold = 0.01):
    i = start
    while i<len(a):
        if(abs(a[i])>threshold):
            return i
        i+=1
    return -1

